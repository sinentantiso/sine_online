{"version":3,"names":["DONE","WeakSet","declare","api","opts","assertVersion","throwIfClosureRequired","tdz","tdzEnabled","Error","name","visitor","VariableDeclaration","path","node","parent","scope","isBlockScoped","convertBlockScopedToVar","_tdzThis","nodes","i","declarations","length","decl","assign","t","assignmentExpression","cloneNode","id","init","buildUndefinedNode","_ignoreBlockScopingTDZ","push","expressionStatement","addHelper","_blockHoist","isCompletionRecord","replaceWithMultiple","Loop","state","ensureBlock","blockScoping","BlockScoping","get","replace","run","replaceWith","CatchClause","ignoreBlock","isLoop","isCatchClause","buildRetCheck","template","statement","isVariableDeclaration","BLOCK_SCOPED_SYMBOL","kind","isInLoop","loopOrFunctionParent","find","isFunction","moveBindingsToParent","isFor","declar","parentScope","getFunctionParent","getProgramParent","Object","keys","getBindingIdentifiers","binding","getOwnBinding","moveBindingTo","isVar","letReferenceFunctionVisitor","traverse","visitors","merge","ReferencedIdentifier","ref","letReferences","localBinding","getBindingIdentifier","closurify","tdzVisitor","letReferenceBlockVisitor","enter","loopDepth","exit","FunctionParent","skip","hoistVarDeclarationsVisitor","self","isForStatement","pushDeclar","sequenceExpression","isForInStatement","isForOfStatement","left","map","expr","loopLabelVisitor","LabeledStatement","innerLabels","label","continuationVisitor","isAssignmentExpression","isUpdateExpression","outsideReferences","reassignments","isReturnStatement","returnStatements","loopNodeTo","isBreakStatement","isContinueStatement","loopVisitor","oldIgnoreLabeless","ignoreLabeless","Function","SwitchCase","oldInSwitchCase","inSwitchCase","loopIgnored","has","loopText","indexOf","hasBreakContinue","set","stringLiteral","hasReturn","objectExpression","objectProperty","identifier","argument","returnStatement","add","inherits","isStrict","isProgram","sourceType","isBlockStatement","directives","some","directive","value","constructor","loopPath","blockPath","block","outsideLetReferences","hasLetReferences","body","loopParent","loopLabel","loop","Map","isLabeledStatement","needsClosure","getLetReferences","checkConstants","updateScopeInfo","wrapClosure","remap","labeledStatement","constBindings","Set","bindings","violation","constantViolations","readOnlyError","throwNode","callExpression","operator","includes","logicalExpression","slice","binaryExpression","unaryExpression","isForXStatement","variableDeclaration","variableDeclarator","generateUidIdentifier","unshift","wrappedInClosure","blockScope","letRefs","key","getBinding","hasOwnBinding","removeBinding","outsideLetRefs","blockPathScope","parentHasBinding","hasGlobal","parentBinding","async","generator","parentPath","rename","buildCodeFrameError","outsideRefs","Array","from","delete","checkLoop","hoistVarDeclarations","args","values","params","isSwitch","type","fn","functionExpression","blockStatement","addContinuations","call","nullLiteral","basePath","hasYield","hasType","FUNCTION_TYPES","yieldExpression","hasAsync","awaitExpression","placeholderPath","index","ret","generateUid","buildHas","callPath","listKey","placeholder","fnPath","loopId","p","insertBefore","unwrapFunctionEnvironment","param","paramName","newParamName","forEach","declarators","names","addDeclarationsFromChild","isClassDeclaration","isFunctionDeclaration","declarPaths","cases","consequents","consequent","j","declars","ifStatement","RETURN"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath, Visitor, Scope, Binding } from \"@babel/traverse\";\nimport { visitor as tdzVisitor } from \"./tdz\";\nimport type { TDZVisitorState } from \"./tdz\";\nimport { traverse, template, types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\n\nconst DONE = new WeakSet();\n\nexport interface Options {\n  tdz?: boolean;\n  throwIfClosureRequired?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const { throwIfClosureRequired = false, tdz: tdzEnabled = false } = opts;\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n\n    visitor: {\n      VariableDeclaration(path) {\n        const { node, parent, scope } = path;\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        if (node._tdzThis) {\n          const nodes: t.Node[] = [node];\n\n          for (let i = 0; i < node.declarations.length; i++) {\n            const decl = node.declarations[i];\n            const assign = t.assignmentExpression(\n              \"=\",\n              t.cloneNode(decl.id),\n              decl.init || scope.buildUndefinedNode(),\n            );\n            // @ts-expect-error todo(flow->ts): avoid mutations\n            assign._ignoreBlockScopingTDZ = true;\n            nodes.push(t.expressionStatement(assign));\n            decl.init = this.addHelper(\"temporalUndefined\");\n          }\n\n          // @ts-expect-error todo(flow->ts): avoid mutations\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            // ensure we don't break completion record semantics by returning\n            // the initialiser of the last declarator\n            nodes.push(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      Loop(path: NodePath<t.Loop>, state) {\n        const { parent, scope } = path;\n        path.ensureBlock();\n        const blockScoping = new BlockScoping(\n          path,\n          path.get(\"body\"),\n          parent,\n          scope,\n          throwIfClosureRequired,\n          tdzEnabled,\n          state,\n        );\n        const replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n\n      CatchClause(path, state) {\n        const { parent, scope } = path;\n        const blockScoping = new BlockScoping(\n          null,\n          path.get(\"body\"),\n          parent,\n          scope,\n          throwIfClosureRequired,\n          tdzEnabled,\n          state,\n        );\n        blockScoping.run();\n      },\n\n      \"BlockStatement|SwitchStatement|Program\"(\n        path: NodePath<t.BlockStatement | t.SwitchStatement | t.Program>,\n        state,\n      ) {\n        if (!ignoreBlock(path)) {\n          const blockScoping = new BlockScoping(\n            null,\n            path,\n            path.parent,\n            path.scope,\n            throwIfClosureRequired,\n            tdzEnabled,\n            state,\n          );\n          blockScoping.run();\n        }\n      },\n    },\n  };\n});\n\nfunction ignoreBlock(\n  path: NodePath<t.BlockStatement | t.SwitchStatement | t.Program>,\n) {\n  return t.isLoop(path.parent) || t.isCatchClause(path.parent);\n}\n\nconst buildRetCheck = template.statement(`\n  if (typeof RETURN === \"object\") return RETURN.v;\n`);\n\nfunction isBlockScoped(node: t.Node): node is t.VariableDeclaration {\n  if (!t.isVariableDeclaration(node)) return false;\n  if (\n    // @ts-expect-error Fixme: document symbol properties\n    node[t.BLOCK_SCOPED_SYMBOL]\n  ) {\n    return true;\n  }\n\n  if (node.kind !== \"let\" && node.kind !== \"const\" && node.kind !== \"using\") {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * If there is a loop ancestor closer than the closest function, we\n * consider ourselves to be in a loop.\n */\nfunction isInLoop(path: NodePath) {\n  const loopOrFunctionParent = path.find(\n    path => path.isLoop() || path.isFunction(),\n  );\n\n  return loopOrFunctionParent?.isLoop();\n}\n\nfunction convertBlockScopedToVar(\n  path: NodePath<t.VariableDeclaration>,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n  scope: Scope,\n  moveBindingsToParent = false,\n) {\n  if (!node) {\n    node = path.node;\n  }\n\n  // https://github.com/babel/babel/issues/255\n  if (isInLoop(path) && !t.isFor(parent)) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  // @ts-expect-error todo(flow->ts): avoid mutations\n  node[t.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  // Move bindings from current block scope to function scope.\n  if (moveBindingsToParent) {\n    const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n    for (const name of Object.keys(path.getBindingIdentifiers())) {\n      const binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node: t.Node): node is t.VariableDeclaration {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !isBlockScoped(node);\n}\n\ninterface LetReferenceVisitorState extends TDZVisitorState {\n  loopDepth: number;\n  closurify: boolean;\n}\n\nconst letReferenceFunctionVisitor = traverse.visitors.merge([\n  {\n    ReferencedIdentifier(path, state) {\n      const ref = state.letReferences.get(path.node.name);\n\n      // not a part of our scope\n      if (!ref) return;\n\n      // this scope has a variable with the same name so it couldn't belong\n      // to our let scope\n      const localBinding = path.scope.getBindingIdentifier(path.node.name);\n      if (localBinding && localBinding !== ref) return;\n\n      state.closurify = true;\n    },\n  },\n  tdzVisitor,\n] as Visitor<LetReferenceVisitorState>[]);\n\nconst letReferenceBlockVisitor = traverse.visitors.merge([\n  {\n    Loop: {\n      enter(path, state) {\n        state.loopDepth++;\n      },\n      exit(path, state) {\n        state.loopDepth--;\n      },\n    },\n    FunctionParent(path, state) {\n      // References to block-scoped variables only require added closures if it's\n      // possible for the code to run more than once -- otherwise it is safe to\n      // simply rename the variables.\n      if (state.loopDepth > 0) {\n        path.traverse(letReferenceFunctionVisitor, state);\n      } else {\n        path.traverse(tdzVisitor, state);\n      }\n      return path.skip();\n    },\n  },\n  tdzVisitor,\n] as Visitor<LetReferenceVisitorState>[]);\n\nconst hoistVarDeclarationsVisitor: Visitor<BlockScoping> = {\n  enter(path, self) {\n    if (path.isForStatement()) {\n      const { node } = path;\n      if (isVar(node.init)) {\n        const nodes = self.pushDeclar(node.init);\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = t.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isForInStatement() || path.isForOfStatement()) {\n      const { node } = path;\n      if (isVar(node.left)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(path.node)) {\n      path.replaceWithMultiple(\n        self.pushDeclar(path.node).map(expr => t.expressionStatement(expr)),\n      );\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  },\n};\n\ntype LoopVisitorState = {\n  inSwitchCase: boolean;\n  hasBreakContinue: boolean;\n  innerLabels: string[];\n  hasReturn: boolean;\n  ignoreLabeless: boolean;\n  loopIgnored: WeakSet<t.Node>;\n  isLoop: boolean;\n  map: Map<string, t.BreakStatement | t.ContinueStatement>;\n};\n\nconst loopLabelVisitor: Visitor<LoopVisitorState> = {\n  LabeledStatement({ node }, state) {\n    state.innerLabels.push(node.label.name);\n  },\n};\n\ninterface ContinuationVisitorState {\n  returnStatements: NodePath<t.ReturnStatement>[];\n  reassignments: { [k: string]: boolean | undefined };\n  outsideReferences: Map<string, t.Identifier>;\n}\n\nconst continuationVisitor: Visitor<ContinuationVisitorState> = {\n  enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      for (const name of Object.keys(path.getBindingIdentifiers())) {\n        if (\n          state.outsideReferences.get(name) !==\n          path.scope.getBindingIdentifier(name)\n        ) {\n          continue;\n        }\n        state.reassignments[name] = true;\n      }\n    } else if (path.isReturnStatement()) {\n      state.returnStatements.push(path);\n    }\n  },\n};\n\nfunction loopNodeTo(node: t.Node) {\n  if (t.isBreakStatement(node)) {\n    return \"break\";\n  } else if (t.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nconst loopVisitor: Visitor<LoopVisitorState> = {\n  Loop(path, state) {\n    const oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n\n  Function(path) {\n    path.skip();\n  },\n\n  SwitchCase(path, state) {\n    const oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n\n  \"BreakStatement|ContinueStatement|ReturnStatement\"(\n    path: NodePath<t.BreakStatement | t.ContinueStatement | t.ReturnStatement>,\n    state,\n  ) {\n    const { node, scope } = path;\n    if (state.loopIgnored.has(node)) return;\n\n    let replace;\n    let loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (t.isReturnStatement(node)) {\n        throw new Error(\n          \"Internal error: unexpected return statement with `loopText`\",\n        );\n      }\n      if (node.label) {\n        // we shouldn't be transforming this because it exists somewhere inside\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = `${loopText}|${node.label.name}`;\n      } else {\n        // we shouldn't be transforming these statements because\n        // they don't refer to the actual loop we're scopifying\n        if (state.ignoreLabeless) return;\n\n        // break statements mean something different in this context\n        if (t.isBreakStatement(node) && state.inSwitchCase) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map.set(loopText, node);\n      replace = t.stringLiteral(loopText);\n    }\n\n    if (t.isReturnStatement(node)) {\n      state.hasReturn = true;\n      replace = t.objectExpression([\n        t.objectProperty(\n          t.identifier(\"v\"),\n          node.argument || scope.buildUndefinedNode(),\n        ),\n      ]);\n    }\n\n    if (replace) {\n      replace = t.returnStatement(replace);\n      state.loopIgnored.add(replace);\n      path.skip();\n      path.replaceWith(t.inherits(replace, node));\n    }\n  },\n};\n\nfunction isStrict(path: NodePath) {\n  return !!path.find(({ node }) => {\n    if (t.isProgram(node)) {\n      if (node.sourceType === \"module\") return true;\n    } else if (!t.isBlockStatement(node)) return false;\n\n    return node.directives.some(\n      directive => directive.value.value === \"use strict\",\n    );\n  });\n}\n\nclass BlockScoping {\n  private parent: t.Node;\n  private state: PluginPass;\n  private scope: Scope;\n  private throwIfClosureRequired: boolean;\n  private tdzEnabled: boolean;\n  private blockPath: NodePath<t.Block | t.SwitchStatement>;\n  private block: t.Block | t.SwitchStatement;\n  private outsideLetReferences: Map<string, t.Identifier>;\n  private hasLetReferences: boolean;\n  private letReferences: Map<string, t.Identifier>;\n  private body: t.Statement[];\n  // todo(flow->ts) add more specific type\n  private loopParent: t.Node;\n  private loopLabel: t.Identifier;\n  private loopPath: NodePath<t.Loop>;\n  private loop: t.Loop;\n  private has: LoopVisitorState;\n  constructor(\n    loopPath: NodePath<t.Loop> | undefined | null,\n    blockPath: NodePath<t.Block | t.SwitchStatement>,\n    parent: t.Node,\n    scope: Scope,\n    throwIfClosureRequired: boolean,\n    tdzEnabled: boolean,\n    state: PluginPass,\n  ) {\n    this.parent = parent;\n    this.scope = scope;\n    this.state = state;\n    this.throwIfClosureRequired = throwIfClosureRequired;\n    this.tdzEnabled = tdzEnabled;\n\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n\n    this.outsideLetReferences = new Map();\n    this.hasLetReferences = false;\n    this.letReferences = new Map();\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel =\n        t.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  /**\n   * Start the ball rolling.\n   */\n\n  run() {\n    const block = this.block;\n    if (DONE.has(block)) return;\n    DONE.add(block);\n\n    const needsClosure = this.getLetReferences();\n\n    this.checkConstants();\n\n    // this is a block within a `Function/Program` so we can safely leave it be\n    if (t.isFunction(this.parent) || t.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    // we can skip everything\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) {\n      return t.labeledStatement(this.loopLabel, this.loop);\n    }\n  }\n\n  checkConstants() {\n    const constBindings = new Map<string, Binding>();\n\n    // In some cases, there are two different scopes: for example,\n    // for (const x of y) {} has a scope for the loop head and one\n    // for the body.\n    for (const scope of new Set([this.scope, this.blockPath.scope])) {\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        if (binding.kind === \"const\") constBindings.set(name, binding);\n      }\n    }\n\n    const { state } = this;\n\n    for (const [name, binding] of constBindings) {\n      for (const violation of binding.constantViolations) {\n        const readOnlyError = state.addHelper(\"readOnlyError\");\n        const throwNode = t.callExpression(readOnlyError, [\n          t.stringLiteral(name),\n        ]);\n\n        if (violation.isAssignmentExpression()) {\n          const { operator } = violation.node;\n          if (operator === \"=\") {\n            violation.replaceWith(\n              t.sequenceExpression([violation.get(\"right\").node, throwNode]),\n            );\n          } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n            violation.replaceWith(\n              t.logicalExpression(\n                // @ts-expect-error todo(flow->ts)\n                operator.slice(0, -1),\n                violation.get(\"left\").node,\n                t.sequenceExpression([violation.get(\"right\").node, throwNode]),\n              ),\n            );\n          } else {\n            violation.replaceWith(\n              t.sequenceExpression([\n                t.binaryExpression(\n                  // @ts-expect-error todo(flow->ts)\n                  operator.slice(0, -1),\n                  violation.get(\"left\").node,\n                  violation.get(\"right\").node,\n                ),\n                throwNode,\n              ]),\n            );\n          }\n        } else if (violation.isUpdateExpression()) {\n          violation.replaceWith(\n            t.sequenceExpression([\n              t.unaryExpression(\"+\", violation.get(\"argument\").node),\n              throwNode,\n            ]),\n          );\n        } else if (violation.isForXStatement()) {\n          // @ts-expect-error TS requires explicit annotation of \"violation\"\n          violation.ensureBlock();\n          violation\n            .get(\"left\")\n            .replaceWith(\n              t.variableDeclaration(\"var\", [\n                t.variableDeclarator(\n                  violation.scope.generateUidIdentifier(name),\n                ),\n              ]),\n            );\n          // @ts-expect-error todo(flow->ts): possible bug \"for(…) switch(){}\"\n          violation.node.body.body.unshift(t.expressionStatement(throwNode));\n        }\n      }\n    }\n  }\n\n  updateScopeInfo(wrappedInClosure?: boolean) {\n    const blockScope = this.blockPath.scope;\n\n    const parentScope =\n      blockScope.getFunctionParent() || blockScope.getProgramParent();\n    const letRefs = this.letReferences;\n\n    for (const key of letRefs.keys()) {\n      const ref = letRefs.get(key);\n      const binding = blockScope.getBinding(ref.name);\n      if (!binding) continue;\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          if (blockScope.hasOwnBinding(ref.name)) {\n            blockScope.removeBinding(ref.name);\n          }\n        } else {\n          blockScope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  }\n\n  remap() {\n    const letRefs = this.letReferences;\n    const outsideLetRefs = this.outsideLetReferences;\n    const scope = this.scope;\n    const blockPathScope = this.blockPath.scope;\n\n    // alright, so since we aren't wrapping this block in a closure\n    // we have to check if any of our let variables collide with\n    // those in upper scopes and then if they do, generate a uid\n    // for them and replace all references with it\n\n    for (const key of letRefs.keys()) {\n      // just an Identifier node we collected in `getLetReferences`\n      // this is the defining identifier of a declaration\n      const ref = letRefs.get(key);\n\n      // todo: could skip this if the colliding binding is in another function\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        const binding = scope.getOwnBinding(key);\n        if (binding) {\n          const parentBinding = scope.parent.getOwnBinding(key);\n          if (\n            binding.kind === \"hoisted\" &&\n            // @ts-expect-error todo(flow->ts)\n            !binding.path.node.async &&\n            // @ts-expect-error todo(flow->ts)\n            !binding.path.node.generator &&\n            (!parentBinding || isVar(parentBi